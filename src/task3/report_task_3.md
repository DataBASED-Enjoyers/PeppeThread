# Реализация read-write lock

## Описание алгоритма

Основной принцип работы `rwlock`:
- Когда поток получает блокировку чтения, то сколько угодно других
потоков могут также получить блокировку на чтение, но ни один поток
не получит блокировку на запись, пока все читающие потоки не вызовут
функцию unlock для данной переменной.
- Когда поток получает блокировку на запись, то ни один другой поток
не сможет получить блокировку ни на чтение, ни на запись

### Структура данных

`rwlock_t` — название структуры, реализующей `rwlock`.
- `lock` — мьютекс.
- `readers_cond` — условная переменная для блокировки/разблокировки потоков, ожидающих возможность _чтения_.
- `writers_cond` — условная переменная для блокировки/разблокировки потоков, ожидающих возможность _записи_.
- `readers` — количество потоков, ожидающих права на чтение.
- `writers` — флаг, показывающий, получил ли блокировку хотя бы один писатель в данный момент.
- `waiting_writers` — количество потоков, ожидающих права на запись.

### Описание работы функций

1. **`rwlock_init`** — инициализация блокировки:
    - Инициализируются мьютекс и условные переменные.
    - Счетчики `readers`, `writers` и `waiting_writers` устанавливаются в 0.

2. **`rwlock_rdlock`** — блокировка для чтения:
    - Поток лочит мьютекс.
    - Если идет запись (`writers > 0`) или есть ожидающие писатели (`waiting_writers > 0`), поток ждет, пока не станет возможным чтение.
    - После того как чтение разрешено, счетчик `readers` увеличивается, и мьютекс освобождается.

3. **`rwlock_wrlock`** — блокировка для записи:
    - Поток лочит мьютекс.
    - Увеличивается счетчик ожидающих писателей (`waiting_writers`).
    - Поток ждет, пока другие писатели или читатели не завершат свою работу.
    - После этого счетчик ожидающих писателей уменьшается, а счетчик писателей (`writers`) увеличивается, сигнализируя о том, что запись началась.
    - Мьютекс освобождается.

4. **`rwlock_unlock`** — снятие блокировки:
    - Поток лочит мьютекс.
    - Если был писатель, счетчик `writers` уменьшается.
    - Иначе если был читатель, счетчик `readers` уменьшается.
    - Если писателей больше нет и есть ожидающие писатели, активируется один из ожидающих писателей с помощью `pthread_cond_signal`. В противном случае, если нет читателей и писателей, активируются все ожидающие читатели с помощью `pthread_cond_broadcast`.
    - Мьютекс освобождается.

5. **`rwlock_destroy`** — уничтожение блокировки:
    - Освобождаются ресурсы, связанные с мьютексом и условными переменными.
  
_Важное замечание!_

Для обеспечения корректной работы программы функцию `pthread_cond_wait` нужно вызывать внутри цикла `while`. Делается это ради следующих целей:
- Обезопасить потоки от спурриозных пробуждений (spurious wakeup), т.е. от случайных пробуждений потоков.
- Защита от состояния гонки (race condition), когда потоки перехватывают друг у друга права на запись/чтение при заданных условиях. Например, если во время работы одного потока другой поток изменит переменные `readers` и `writers`, то первый может сработать некорретно.

## Оценка времени работы

1. **`rwlock_init`** — Время работы O(1).

2. **`rwlock_rdlock`** — Если нет активных писателей или ожидающих писателей, то выполняется за O(1), иначе время неопределено.

3. **`rwlock_wrlock`** — Если нет активных писателей или читателей, то выполняется за O(1), иначе время неопределено.

4. **`rwlock_unlock`** — Если нет ожидания других потоков, то выполняется за O(1), иначе время не определено.

5. **`rwlock_destroy`** — Время работы O(1).

## Измерение времени выполнения

---

## Основные метрики параллельной реализации

Для оценки эффективности параллельной реализации используются следующие метрики:

- **Ускорение (S)**:

  $`
  S = \frac{T_{\text{послед}}}{T_{\text{паралл}}}
  `$

- **Эффективность (E)**:

  $`
  E = \frac{S}{nthreads}
  `$

## Результаты тестов

---

## Анализ результатов

---

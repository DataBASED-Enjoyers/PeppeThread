# Оценка числа π методом Монте-Карло с использованием многопоточности

Алгоритм для оценки значения числа π методом Монте-Карло был реализован с использованием многопоточности через библиотеку `pthreads`.

## Описание алгоритма

Алгоритм предназначен для оценки значения числа π с помощью метода Монте-Карло, который основан на статистическом подходе. Суть метода заключается в следующем:

1. **Генерация случайных точек**: Создаются случайные точки (x, y) внутри квадрата с координатами от -1 до 1.

2. **Проверка попадания в окружность**: Для каждой точки проверяется условие \( x^2 + y^2 \leq 1 \), что означает, что точка находится внутри единичной окружности, вписанной в квадрат.

3. **Вычисление π**: Отношение числа точек, попавших в окружность, к общему числу сгенерированных точек приближает значение \( \frac{π}{4} \). Умножая это отношение на 4, получаем оценку числа π.


Общее число испытаний (`ntrials`) равномерно распределяется между потоками, каждый из которых выполняет функцию `compute_pi`. В этой функции генерируются точки и подсчитывается количество попаданий в окружность. После завершения работы всех потоков результаты суммируются, объединяя количество попаданий.

## Измерение времени выполнения

Время выполнения программы измеряется с помощью функций замера времени до начала вычислений и после их окончания. 

Общее время выполнения зависит от двух факторов:
- **Число потоков (`nthreads`)**: увеличение количества потоков должно сокращать время выполнения до определённого предела.
- **Число испытаний (`ntrials`)**: большее количество испытаний повышает точность оценки числа π, но увеличивает время выполнения.

## Основные метрики параллельной реализации

Для оценки эффективности параллельной реализации используются следующие метрики:

- **Ускорение (S)**:

  $`
  S = \frac{T_{\text{послед}}}{T_{\text{паралл}}}
  `$

- **Эффективность (E)**:

  $`
  E = \frac{S}{nthreads}
  `$

## Результаты тестов

### Тест 1
* `ntrials = 100000`
* Используется `rand_r()` для создания случайных точек

| Количество потоков | Среднее время выполнения (`T_avg`), сек | Ускорение (`S`) | Эффективность (`E`) |
|--------------------|-----------------------------------------|-----------------|---------------------|
| 1 (последовательный алгоритм) | 0.001059 | -       | -       |
| 2  | 0.001281 | 0.8266 | 0.4133 |
| 8  | 0.000792 | 1.3362 | 0.1670 |
| 16 | 0.000806 | 1.3133 | 0.0820 |
| 64 | 0.001709 | 0.6193 | 0.0096 |

Файлы со статистической информацией по времени выполнения находятся в `.csv`-файлах: `benchmarks_ntrials=1000000_rand_r/execution_times_n_threads.csv`.

### Тест 2
* `ntrials = 100000`
* Используется `drand48_r()` для создания случайных точек

| Количество потоков | Среднее время выполнения (`T_avg`), сек | Ускорение (`S`) | Эффективность (`E`) |
|--------------------|-----------------------------------------|-----------------|---------------------|
| 1 (последовательный алгоритм) | 0.001281 | -       | -       |
| 2  | 0.000690 | 1.7222 | 0.8611 |
| 8  | 0.000514 | 2.3145 | 0.2893 |
| 16 | 0.000656 | 1.8124 | 0.1132 |
| 64 | 0.001728 | 0.6881 | 0.0107 |


Файлы со статистической информацией по времени выполнения находятся в `.csv`-файлах: `benchmarks_ntrials=100000_drand48_r/execution_times_n_threads.csv`.

### Тест 3
* `ntrials = 10000000`
* Используется `drand48_r()` для создания случайных точек

| Количество потоков | Среднее время выполнения (`T_avg`), сек | Ускорение (`S`) | Эффективность (`E`) |
|--------------------|-----------------------------------------|-----------------|---------------------|
| 1 (последовательный алгоритм) | 0.105536 | -       | -       |
| 2  | 0.053416 | 1.9757 | 0.9878 |
| 8  | 0.020361 | 5.1831 | 0.6478 |
| 16 | 0.017123 | 6.1632 | 0.3852 |
| 64 | 0.015155 | 6.9639 | 0.1088 |


Файлы со статистической информацией по времени выполнения находятся в `.csv`-файлах: `benchmarks_ntrials=10000000_drand48_r/execution_times_n_threads.csv`.

---

## Анализ результатов

При решении проблемы плохих результатов Теста 1 было принято решение поменять используемую библиотеку случайных чисел с `rand_r` на `drand48_r`.

По итогам тестов можно заметить, что использование многопоточности существенно снижает время выполнения задачи вычисления числа π методом Монте-Карло. По росту ускорения и эффективности в Тесте 3 можно заметить, что значительная часть оверхэда в нашей реализации приходится на нераспаралелливаемый код, поскольку с ростом числа точек и ускорение, и эффективность значительно выросли. Лучшие результаты по ускорению показал тест с 64 потоками, что соответствует ожиданиям, поскольку из всех тестов только он использует всех (20) работников машины, используемой для тестирования; однако, эффективность ожидаемо падала с ростом числа потоков и была максимальной для двух потоков в наиболее достоверном из наших тестов (Тесте 3).
